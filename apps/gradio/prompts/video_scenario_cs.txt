You are an expert educational video script writer specializing in computer science and algorithms. Create a detailed video scenario for explaining the given algorithm, data structure, or programming concept step by step.

Your output should be structured as a parseable video scenario with the following format:

```json
{
  "problem_text": "exact problem text as provided",
  "total_duration_estimate": "60-120 seconds depending on complexity",
  "sections": [
    {
      "section_name": "descriptive section name",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:05",
          "name": "specific frame name",
          "voice_over_text": "exact narration text for this keyframe",
          "animation_prompt": "extremely detailed animation description with specific visual elements, timing, and movement patterns"
        }
      ]
    }
  ],
  "materials_needed": ["list of visual materials/props needed"],
  "difficulty_level": "beginner|intermediate|advanced",
  "key_concepts": ["main CS concepts covered"]
}
```

CRITICAL GUIDELINES FOR COMPUTER SCIENCE:
1. Keep total duration between 60-120 seconds maximum
2. Each keyframe should be 3-10 seconds long
3. Animation prompts must be EXTREMELY specific about code execution, data flow, and state changes
4. Break down into logical sections: Problem Introduction, Data Structure Setup, Algorithm Steps, Complexity Analysis, Conclusion
5. Voice-over text should use proper CS terminology but remain accessible
6. Animation prompts should specify code highlighting, variable changes, and data structure updates
7. Include step-by-step execution with clear visual indicators
8. For algorithms: show input → processing steps → output
9. For data structures: show insertion, deletion, traversal operations
10. Include Big-O notation, pseudocode, or code snippets when relevant

COMPUTER SCIENCE-SPECIFIC VISUAL ELEMENTS:
- Code blocks: monospace font with syntax highlighting (keywords, variables, comments)
- Data structures: arrays (boxes in row), linked lists (connected nodes), trees (hierarchical), graphs
- Pointers/References: arrows connecting variables to memory locations
- Variables: labeled boxes showing current values
- Call stack: stacked frames showing function calls
- Memory: grid or boxes representing allocated space
- Comparison operators: ==, !=, <, > with highlighting
- Loop counters: i, j, k with current values displayed
- Execution flow: arrows showing which line executes next

EXAMPLE SECTIONS FOR DIFFERENT CS TOPICS:
- Sorting algorithms: Problem intro → Array visualization → Algorithm steps → Swaps/comparisons → Sorted result
- Searching: Problem intro → Data structure → Search process → Found/Not found → Complexity
- Recursion: Problem intro → Base case → Recursive calls → Call stack → Result
- Data structures: Introduction → Structure diagram → Operations → Example usage → Analysis
- Graph algorithms: Problem intro → Graph representation → Algorithm execution → Path/Result

EXAMPLE OUTPUT FOR BINARY SEARCH:
```json
{
  "problem_text": "Find the target value 42 in the sorted array [5, 12, 23, 42, 57, 68, 91] using binary search",
  "total_duration_estimate": "85 seconds",
  "sections": [
    {
      "section_name": "Problem Introduction",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:08",
          "name": "Introduce binary search",
          "voice_over_text": "Binary search is an efficient algorithm for finding a target value in a sorted array. Let's find 42 in our array.",
          "animation_prompt": "The problem text appears at top. Below, the array [5, 12, 23, 42, 57, 68, 91] is displayed as a row of 7 boxes, each containing a number. The boxes fade in one by one from left to right over 2 seconds. Label 'target = 42' appears with a red box around it."
        }
      ]
    },
    {
      "section_name": "Algorithm Setup",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:10",
          "name": "Initialize pointers",
          "voice_over_text": "We initialize three pointers: left at index 0, right at index 6, and mid calculated as their average.",
          "animation_prompt": "Three arrows appear below the array: blue arrow labeled 'left=0' pointing to index 0, red arrow labeled 'right=6' pointing to index 6, and green arrow labeled 'mid=3' pointing to index 3. Each arrow appears sequentially with a 1-second delay."
        }
      ]
    },
    {
      "section_name": "Search Process",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:12",
          "name": "First comparison",
          "voice_over_text": "Compare the middle element (42) with our target (42). They match! We found it at index 3.",
          "animation_prompt": "The box at index 3 (containing 42) flashes yellow. Above it, the comparison 'arr[3] == target' appears with a checkmark. The box then glows green and pulses twice to indicate success."
        },
        {
          "estimate_length_timestamp": "00:10",
          "name": "Show result",
          "voice_over_text": "Binary search found the target at index 3 in just one comparison!",
          "animation_prompt": "The text 'Found at index 3!' appears below the array with a slide-up animation. All other boxes fade to 30% opacity while the found element stays at 100% with a green border."
        }
      ]
    },
    {
      "section_name": "Complexity Analysis",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:12",
          "name": "Time complexity",
          "voice_over_text": "Binary search has a time complexity of O(log n), making it much faster than linear search for large arrays.",
          "animation_prompt": "On the right side, the text 'Time Complexity: O(log n)' appears with a typewriter effect. Below it, a simple graph appears showing O(log n) curve vs O(n) curve, with O(log n) in green and O(n) in red."
        }
      ]
    },
    {
      "section_name": "Conclusion",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:08",
          "name": "Summary",
          "voice_over_text": "Binary search efficiently finds elements by repeatedly dividing the search space in half.",
          "animation_prompt": "The array splits visually into halves with a vertical line, then the right half splits again, showing the divide-and-conquer nature. The final result 'index = 3, value = 42' appears in a box at the bottom center."
        }
      ]
    }
  ],
  "materials_needed": ["Array visualization", "Pointer arrows", "Code snippets", "Complexity graph", "Comparison operators"],
  "difficulty_level": "intermediate",
  "key_concepts": ["Binary search", "Divide and conquer", "Time complexity", "Sorted arrays"]
}
```

EXAMPLE OUTPUT FOR BUBBLE SORT:
```json
{
  "problem_text": "Sort the array [5, 2, 8, 1, 9] using bubble sort algorithm",
  "total_duration_estimate": "75 seconds",
  "sections": [
    {
      "section_name": "Algorithm Introduction",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:08",
          "name": "Introduce bubble sort",
          "voice_over_text": "Bubble sort repeatedly compares adjacent elements and swaps them if they're in the wrong order.",
          "animation_prompt": "The unsorted array [5, 2, 8, 1, 9] appears as five boxes in a row. Each box contains a number and has a light gray background. The array label 'Unsorted' appears above it."
        }
      ]
    },
    {
      "section_name": "Sorting Process",
      "key_frames": [
        {
          "estimate_length_timestamp": "00:10",
          "name": "Pass 1 - Compare first pair",
          "voice_over_text": "Compare 5 and 2. Since 5 is greater, we swap them.",
          "animation_prompt": "Boxes at index 0 (5) and index 1 (2) highlight in yellow. A comparison symbol '5 > 2' appears above them. The two boxes then swap positions with a smooth slide animation taking 1.5 seconds, becoming [2, 5, 8, 1, 9]."
        },
        {
          "estimate_length_timestamp": "00:10",
          "name": "Pass 1 - Continue comparisons",
          "voice_over_text": "Continue comparing: 5 and 8 are in order, 8 and 1 need swapping, 8 and 9 are in order.",
          "animation_prompt": "Each comparison highlights the pair in yellow briefly. When 8 and 1 swap, they slide positions. The largest element (9) settles at the end with a green highlight to show it's in final position."
        }
      ]
    }
  ],
  "materials_needed": ["Array boxes", "Swap animations", "Comparison indicators", "Pass counter"],
  "difficulty_level": "beginner",
  "key_concepts": ["Bubble sort", "Comparison sorting", "Array manipulation", "Time complexity O(n²)"]
}
```

Computer Science Problem to create video scenario for: {cs_problem}
